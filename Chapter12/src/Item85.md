# Item 85. 자바 직렬화의 대안을 찾으라
## 직렬화의 근본적인 문제점
공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다. 
0bjectInputStream의 readobject 메서드를 호출하면서 객체 그래프가 역직렬화되기 때문이다.

신뢰할 수 없는 스트림을 역직렬화하면 원격 코드 실행(remote code execution, RCE), 서비스 거부(denial-of-service, Dos) 등의 공격으로 이어질 수 있다. 

### 가젯
서드파티 라이브러리에서 역직렬화 과정에 호출되어 잠재적으로 위험한 동작을 수행하는 메서드들을 가젯(gadget)이라고 부른다. 
여러 가젯을 함께 사용하여 가젯 체인을 구성할 수도 있다.
따라서 신중하게 제작한 바이트 스트림만 역직렬화해야 한다. 샌프란시스코 교통국을 마비시킨 공격이 정확히 이런 사례로, 가젯들이 체인으로 엮여 피해가 더욱 컸다. 이 외에도 여 러 공격이 있었을 것이고, 앞으로도 더 있을 것이다.

### 역직렬화 폭탄
역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있다. 
이런 스트림을 역직렬화 폭탄(deserialization bomb)이라고 한다.

## 크로스-플랫폼 구조화된 데이터 표현
직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다. 
우리가 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다.
객체와 바이트 시퀀스를 변환해주는 다른 메커니즘은 수많은 이점을 제공한다. 
이런 메커니즘들은 크로스-플랫폼 구조화된 데이터 표현(cross-platomm structured-cata representation)'이라 한다.

### 크로스-플랫폼 구조화된 데이터 표현의 종류
JSON과 프로토콜 버퍼 (Protocol Buffers 혹은 짧게 protobut)

#### 공통점
자바 직렬화보다 훨씬 간단하다는 것이다. 
속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용한다. 그리고 기본 타입 몇 개와 배열 타입만 지원할 뿐이다. 이런 간단한 추상화만으로도 아주 강력한 분산 시 스템을 구축하기에 충분하고, 자바 직렬화가 가져온 심각한 문제들을 회피할 수 있음이 밝혀졌다.
크로스-플랫폼 구조화된 데이터 표현의 선두주자는 다. JSON은 더글라스 크록퍼드(Douglas Crockford)가 브라우저와 서버의 통신용으로 설계했고, 프로토콜 버퍼는 구글 이 서버 사이에 데이터를 교환하고 저장하기 위해 설계했다. 보통은 이들을 언 어 중립적이라고 하지만, 사실 JSON은 자바스크립트용으로, 프로토콜 버퍼는 CH+용으로 만들어졌고, 아직도 그 흔적이 남아 있다.
둘의 가장 큰 차이는 JSON은 텍스트 기반이라 사람이 읽을 수 있고, 프로토 콜 버퍼는 이진 표현이라 효율이 훨씬 높다는 점이다. 또한 JSON은 오직 데이 터를 표현하는 데만 쓰이지만, 프로토콜 버퍼는 문서를 위한 스키마(타입)를 제공하고 올바로 쓰도록 강요한다. 효율은 프로토콜 버퍼가 훨씬 좋지만 텍스 트 기반 표현에는 JSON이 아주 효과적이다. 또한, 프로토콜 버퍼는 이진 표현 뿐 아니라 사람이 읽을 수 있는 텍스트 표현(pbxt)도 지원한다.
레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 때의 차선책은 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다. 특히, 신뢰할 수 없 는 발신원으로부터의 RMI는 절대 수용해서는 안 된다. 자바의 공식 보안 코 딩 지침에서는 "신뢰할 수 없는 데이터의 역직렬화는 본질적으로 위험하므로 절대로 피해야 한다"라고 조언한다. 이 문장은 글씨가 크고 굵으며, 붉은 색에 기울임꼴로 되어 있다. 문서 전체에서 이 문장만 이렇게 강조해 놓았다. Uava-
secure]
직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없 다면 객체 역직렬화 필터링(java.io.objectInputFilter)을 사용하자(자바 9 에 추가되었고, 이전 버전에서도 쓸 수 있도록 이식되었다). 객체 역직렬화 필 터링은 데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이