# Item 78. 공유 중인 가변 데이터는 동기화해 사용하라
synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다. 
많은 프로그래머가 동기화를 배타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다. 
동기화를 제대로 사용하면 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없다.

동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.

동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.

## 다른 스레드를 멈추는 작업
### 잘못된 방법
Thread.stop 메서드는 데이터를 훼손할 수 있으므로 deprecated API로 지정되었다.
따라서 Thread.stop은 사용하면 안 된다.

### 올바른 방법
첫 번째 스레드는 자신의 boolean 필드를 폴링하면서 그 값이 true가 되면 멈춘다.


쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않는다. 

반복문에서 매번 동기화하는 비용이 크진 않지만 속도가 더 빠른 대안을 소개하겠다. 
필드를 volatile으로 선언하면 동기화를 생략해도 된다. 
volatile 한정자는 배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다.

volatile은 주의해서 사용해야 한다